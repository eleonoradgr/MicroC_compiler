### Starting build.
# Target: src/microcc.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/microcc.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/microcc.ml > src/microcc.ml.depends # cached
# Target: src/ast.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/ast.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/ast.ml > src/ast.ml.depends # cached
# Target: src/ast.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/ast.cmo, file:src/ast.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/ast.cmo src/ast.ml # cached
# Target: src/codegen.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/codegen.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/codegen.ml > src/codegen.ml.depends # cached
# Target: src/semant.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/semant.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/semant.ml > src/semant.ml.depends # cached
# Target: src/symbol_table.mli.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:mli, file:src/symbol_table.mli, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/symbol_table.mli > src/symbol_table.mli.depends # cached
# Target: src/symbol_table.cmi, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:mli, file:src/symbol_table.mli, include, interf, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/symbol_table.cmi src/symbol_table.mli # cached
# Target: src/tast.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/tast.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/tast.ml > src/tast.ml.depends # cached
# Target: src/tast.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/tast.cmo, file:src/tast.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/tast.cmo src/tast.ml # cached
# Target: src/util.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/util.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/util.ml > src/util.ml.depends # cached
# Target: src/util.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/util.cmo, file:src/util.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/util.cmo src/util.ml # cached
# Target: src/semant.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/semant.cmo, file:src/semant.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/semant.cmo src/semant.ml # cached
# Target: src/codegen.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/codegen.cmo, file:src/codegen.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/codegen.cmo src/codegen.ml # cached
# Target: src/opt_pass.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/opt_pass.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/opt_pass.ml > src/opt_pass.ml.depends # cached
# Target: src/opt_pass.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/opt_pass.cmo, file:src/opt_pass.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/opt_pass.cmo src/opt_pass.ml # cached
# Target: src/parser_engine.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/parser_engine.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/parser_engine.ml > src/parser_engine.ml.depends # cached
# Target: src/parser.mly.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:mly, file:src/parser.mly, include, infer, menhir_ocamldep, ocaml, ocamldep, quiet, traverse, use_menhir }
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/parser.mly > src/parser.mly.depends # cached
# Target: src/parser.mly, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:ml, extension:mly, file:src/parser.ml, file:src/parser.mly, include, infer, menhir, ocaml, parser, quiet, traverse, use_menhir }
menhir --ocamlc 'ocamlfind ocamlc -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src' --infer src/parser.mly # cached
# Target: src/parser.mli.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:mli, file:src/parser.mli, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/parser.mli > src/parser.mli.depends # cached
# Target: src/parser.cmi, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:mli, file:src/parser.mli, include, interf, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/parser.cmi src/parser.mli # cached
# Target: src/scanner.mll, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:mll, file:src/scanner.mll, include, lexer, ocaml, ocamllex, quiet, traverse, use_menhir }
/usr/bin/ocamllex.opt -q src/scanner.mll # cached
# Target: src/scanner.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/scanner.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/scanner.ml > src/scanner.ml.depends # cached
# Target: src/scanner.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/scanner.cmo, file:src/scanner.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/scanner.cmo src/scanner.ml # cached
# Target: src/parser_engine.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/parser_engine.cmo, file:src/parser_engine.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/parser_engine.cmo src/parser_engine.ml # cached
# Target: src/microcc.cmo, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), byte, compile, extension:cmo, extension:ml, file:src/microcc.cmo, file:src/microcc.ml, implem, include, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlc -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/microcc.cmo src/microcc.ml # cached
# Target: src/ast.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/ast.cmx, file:src/ast.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/ast.cmx src/ast.ml # cached
# Target: src/symbol_table.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/symbol_table.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/symbol_table.ml > src/symbol_table.ml.depends # cached
# Target: src/symbol_table.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/symbol_table.cmx, file:src/symbol_table.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/symbol_table.cmx src/symbol_table.ml # cached
# Target: src/tast.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/tast.cmx, file:src/tast.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/tast.cmx src/tast.ml # cached
# Target: src/util.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/util.cmx, file:src/util.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/util.cmx src/util.ml # cached
# Target: src/semant.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/semant.cmx, file:src/semant.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/semant.cmx src/semant.ml # cached
# Target: src/codegen.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/codegen.cmx, file:src/codegen.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/codegen.cmx src/codegen.ml # cached
# Target: src/opt_pass.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/opt_pass.cmx, file:src/opt_pass.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/opt_pass.cmx src/opt_pass.ml # cached
# Target: src/parser.ml.depends, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), extension:ml, file:src/parser.ml, include, ocaml, ocamldep, quiet, traverse, use_menhir }
ocamlfind ocamldep -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -modules src/parser.ml > src/parser.ml.depends # cached
# Target: src/parser.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/parser.cmx, file:src/parser.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/parser.cmx src/parser.ml # cached
# Target: src/scanner.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/scanner.cmx, file:src/scanner.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/scanner.cmx src/scanner.ml # cached
# Target: src/parser_engine.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/parser_engine.cmx, file:src/parser_engine.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/parser_engine.cmx src/parser_engine.ml # cached
# Target: src/microcc.cmx, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), compile, extension:cmx, extension:ml, file:src/microcc.cmx, file:src/microcc.ml, implem, include, native, ocaml, quiet, traverse, use_menhir }
ocamlfind ocamlopt -c -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src -o src/microcc.cmx src/microcc.ml # cached
# Target: src/microcc.native, tags: { package(llvm), package(llvm.bitwriter), package(llvm.scalar_opts), package(menhirLib), package(ppx_deriving.std), dont_link_with, extension:native, file:src/microcc.native, include, link, native, ocaml, program, quiet, traverse, use_menhir }
ocamlfind ocamlopt -linkpkg -package menhirLib -package ppx_deriving.std -package llvm.scalar_opts -package llvm.bitwriter -package llvm -I src src/ast.cmx src/symbol_table.cmx src/tast.cmx src/util.cmx src/semant.cmx src/codegen.cmx src/opt_pass.cmx src/parser.cmx src/scanner.cmx src/parser_engine.cmx src/microcc.cmx -o src/microcc.native # cached
# Compilation successful.
